import { TastingData } from './realm/types';
import { HomeCafeData, PouroverDripper, FilterType, PourTechnique } from '../types/tasting';
import { SelectedSensoryExpression } from '../types/tasting';
import RealmService from './realm/RealmService';
import { Logger } from '../utils/logger';
import { MouthfeelType, AgitationType } from '../types/tasting';
import { TastingRecord } from './realm/types';

export enum MockDataScenario {
  BEGINNER = 'beginner',
  INTERMEDIATE = 'intermediate', 
  EXPERT = 'expert',
  HOME_CAFE_FOCUSED = 'home_cafe_focused',
  STATISTICS_TEST = 'statistics_test'
}

export interface MockDataOptions {
  scenario: MockDataScenario;
  count: number;
  includeHomeCafe?: boolean;
  includePhotos?: boolean;
}

export class MockDataService {
  /**
   * Generate mock tasting records based on scenario
   */
  static generateTastingRecords(options: MockDataOptions): TastingData[] {
    const { scenario, count, includeHomeCafe = true } = options;
    
    switch (scenario) {
      case MockDataScenario.BEGINNER:
        return this.generateBeginnerData(count, includeHomeCafe);
      case MockDataScenario.INTERMEDIATE:
        return this.generateIntermediateData(count, includeHomeCafe);
      case MockDataScenario.EXPERT:
        return this.generateExpertData(count, includeHomeCafe);
      case MockDataScenario.HOME_CAFE_FOCUSED:
        return this.generateHomeCafeData(count);
      case MockDataScenario.STATISTICS_TEST:
        return this.generateStatisticsTestData(count, includeHomeCafe);
      default:
        return this.generateIntermediateData(count, includeHomeCafe);
  }
}

  /**
   * Beginner-friendly data with simple flavor expressions
   */
  private static generateBeginnerData(count: number, includeHomeCafe: boolean): TastingData[] {
    const data: TastingData[] = [];
    const beginnerFlavors = [
      { level: 1, value: 'Sweet', koreanValue: 'ë‹¬ì½¤í•œ' },
      { level: 1, value: 'Bitter', koreanValue: 'ì“´ë§›' },
      { level: 1, value: 'Sour', koreanValue: 'ì‹ ë§›' },
      { level: 2, value: 'Chocolate', koreanValue: 'ì´ˆì½œë¦¿' },
      { level: 2, value: 'Caramel', koreanValue: 'ìºëŸ¬ë©œ' },
      { level: 2, value: 'Nutty', koreanValue: 'ê²¬ê³¼ë¥˜' }
    ];

    const cafes = ['ìŠ¤íƒ€ë²…ìŠ¤', 'íˆ¬ì¸í”Œë ˆì´ìŠ¤', 'ë©”ê°€ì»¤í”¼', 'ì»¤í”¼ë¹ˆ'];
    const roasteries = ['ìŠ¤íƒ€ë²…ìŠ¤', 'íˆ¬ì¸', 'ë©”ê°€ì»¤í”¼', 'ì»¤í”¼ë¹ˆ'];
    const coffeeNames = ['ì•„ë©”ë¦¬ì¹´ë…¸', 'ì¹´í˜ë¼ë–¼', 'ì¹´í‘¸ì¹˜ë…¸', 'ë¸Œë£¨ë“œì»¤í”¼'];

    for (let i = 0; i < count; i++) {
      const isHomeCafe = includeHomeCafe && Math.random() > 0.7;
      
      data.push({
        coffeeInfo: {
          cafeName: isHomeCafe ? undefined : cafes[i % cafes.length],
          roastery: roasteries[i % roasteries.length],
          coffeeName: coffeeNames[i % coffeeNames.length],
          origin: ['ë¸Œë¼ì§ˆ', 'ì½œë¡¬ë¹„ì•„', 'ì—í‹°ì˜¤í”¼ì•„', 'ê³¼í…Œë§ë¼'][i % 4],
          variety: ['ì•„ë¼ë¹„ì¹´', 'ë¡œë¶€ìŠ¤íƒ€'][i % 2],
          altitude: ['1200m', '1500m', '1800m'][i % 3],
          process: ['ì›Œì‹œë“œ', 'ë‚´ì¶”ëŸ´', 'í—ˆë‹ˆ'][i % 3],
          temperature: ['hot', 'cold'][i % 2] as 'hot' | 'cold'
      },
        roasterNotes: `ì´ˆë³´ìë¥¼ ìœ„í•œ ${i + 1}ë²ˆì§¸ ì»¤í”¼ í…Œì´ìŠ¤íŒ…`,
        selectedFlavors: beginnerFlavors.slice(0, Math.floor(Math.random() * 3) + 1),
        selectedSensoryExpressions: this.generateBeginnerSensoryData(),
        sensoryAttributes: {
          body: Math.floor(Math.random() * 3) + 2, // 2-4 range
          acidity: Math.floor(Math.random() * 3) + 2,
          sweetness: Math.floor(Math.random() * 3) + 2,
          finish: Math.floor(Math.random() * 3) + 2,
          mouthfeel: ['Clean', 'Creamy'][Math.floor(Math.random() * 2)] as 'Clean' | 'Creamy',
          bitterness: Math.floor(Math.random() * 3) + 2,
          balance: Math.floor(Math.random() * 3) + 2
      },
        matchScore: {
          total: Math.floor(Math.random() * 30) + 60, // 60-90 range
          flavorScore: Math.floor(Math.random() * 15) + 30,
          sensoryScore: Math.floor(Math.random() * 15) + 30
      },
        personalComment: `ì´ˆë³´ì ê´€ì ì—ì„œ ${i + 1}ë²ˆì§¸ ì»¤í”¼ ê²½í—˜`,
        mode: isHomeCafe ? 'home_cafe' : 'cafe',
        homeCafeData: isHomeCafe ? this.generateSimpleHomeCafeData() : undefined
    });
  }

    return data;
}

  /**
   * Intermediate data with moderate complexity
   */
  private static generateIntermediateData(count: number, includeHomeCafe: boolean): TastingData[] {
    const data: TastingData[] = [];
    const intermediateFlavors = [
      { level: 1, value: 'Fruity', koreanValue: 'ê³¼ì¼í–¥' },
      { level: 2, value: 'Berry', koreanValue: 'ë² ë¦¬ë¥˜' },
      { level: 3, value: 'Blueberry', koreanValue: 'ë¸”ë£¨ë² ë¦¬' },
      { level: 1, value: 'Floral', koreanValue: 'ê½ƒí–¥' },
      { level: 2, value: 'White Floral', koreanValue: 'í° ê½ƒ' },
      { level: 3, value: 'Jasmine', koreanValue: 'ììŠ¤ë¯¼' },
      { level: 1, value: 'Chocolate', koreanValue: 'ì´ˆì½œë¦¿' },
      { level: 2, value: 'Dark Chocolate', koreanValue: 'ë‹¤í¬ ì´ˆì½œë¦¿' }
    ];

    const specialtyCafes = ['ë¸”ë£¨ë³´í‹€', 'ìŠ¤í„°í”„ë“œ', 'í”„ë¦¬ì¸ ', 'ì•¤íŠ¸ë¼ì‚¬ì´íŠ¸'];
    const specialtyRoasteries = ['ì»¤í”¼ë¦¬ë¸Œë ˆ', 'í…Œë¼ë¡œì‚¬', 'ë“œë¡­íƒ‘', 'ë¹ˆë¸Œë¼ë”ìŠ¤'];
    const specialtyCoffees = ['ì—í‹°ì˜¤í”¼ì•„ ì˜ˆê°€ì²´í”„', 'ì¼€ëƒ AA', 'ê³¼í…Œë§ë¼ ì•ˆí‹°êµ¬ì•„', 'ì½”ìŠ¤íƒ€ë¦¬ì¹´ íƒ€ë¼ì£¼'];

    for (let i = 0; i < count; i++) {
      const isHomeCafe = includeHomeCafe && Math.random() > 0.5;
      
      data.push({
        coffeeInfo: {
          cafeName: isHomeCafe ? undefined : specialtyCafes[i % specialtyCafes.length],
          roastery: specialtyRoasteries[i % specialtyRoasteries.length],
          coffeeName: specialtyCoffees[i % specialtyCoffees.length],
          origin: ['Ethiopia', 'Kenya', 'Guatemala', 'Costa Rica'][i % 4],
          variety: ['Heirloom', 'SL28', 'Bourbon', 'Catuai'][i % 4],
          altitude: ['1600m', '1800m', '2000m', '2200m'][i % 4],
          process: ['Washed', 'Natural', 'Honey', 'Anaerobic'][i % 4],
          temperature: ['hot', 'cold'][i % 2] as 'hot' | 'cold'
      },
        roasterNotes: `ì¤‘ê¸‰ìë¥¼ ìœ„í•œ ìŠ¤í˜ì…œí‹° ì»¤í”¼ #${i + 1}. ë³µí•©ì ì¸ í–¥ë¯¸ í”„ë¡œí•„ì„ ê°€ì§„ ì»¤í”¼`,
        selectedFlavors: intermediateFlavors.slice(0, Math.floor(Math.random() * 5) + 2),
        selectedSensoryExpressions: this.generateIntermediateSensoryData(),
        sensoryAttributes: {
          body: Math.floor(Math.random() * 5) + 1,
          acidity: Math.floor(Math.random() * 5) + 1,
          sweetness: Math.floor(Math.random() * 5) + 1,
          finish: Math.floor(Math.random() * 5) + 1,
          mouthfeel: ['Clean', 'Creamy', 'Juicy', 'Silky'][Math.floor(Math.random() * 4)] as MouthfeelType,
          bitterness: Math.floor(Math.random() * 5) + 1,
          balance: Math.floor(Math.random() * 5) + 1
      },
        matchScore: {
          total: Math.floor(Math.random() * 40) + 70, // 70-100 range
          flavorScore: Math.floor(Math.random() * 20) + 35,
          sensoryScore: Math.floor(Math.random() * 20) + 35
      },
        personalComment: `ì¤‘ê¸‰ì í…Œì´ìŠ¤íŒ… ë…¸íŠ¸ #${i + 1}: í–¥ë¯¸ì˜ ë³µí•©ì„±ê³¼ ê· í˜•ê°ì´ ì¸ìƒì `,
        mode: isHomeCafe ? 'home_cafe' : 'cafe',
        homeCafeData: isHomeCafe ? this.generateDetailedHomeCafeData() : undefined
    });
  }

    return data;
}

  /**
   * Expert data with complex flavor profiles
   */
  private static generateExpertData(count: number, includeHomeCafe: boolean): TastingData[] {
    const data: TastingData[] = [];
    const expertFlavors = [
      { level: 1, value: 'Fruity', koreanValue: 'ê³¼ì¼í–¥' },
      { level: 2, value: 'Stone Fruit', koreanValue: 'í•µê³¼ë¥˜' },
      { level: 3, value: 'Peach', koreanValue: 'ë³µìˆ­ì•„' },
      { level: 4, value: 'White Peach', koreanValue: 'ë°±ë„' },
      { level: 1, value: 'Floral', koreanValue: 'ê½ƒí–¥' },
      { level: 2, value: 'Rose', koreanValue: 'ì¥ë¯¸' },
      { level: 3, value: 'Tea Rose', koreanValue: 'ì°¨ì¥ë¯¸' },
      { level: 1, value: 'Spices', koreanValue: 'í–¥ì‹ ë£Œ' },
      { level: 2, value: 'Sweet Spice', koreanValue: 'ë‹¬ì½¤í•œ í–¥ì‹ ë£Œ' },
      { level: 3, value: 'Cinnamon', koreanValue: 'ê³„í”¼' },
      { level: 4, value: 'Ceylon Cinnamon', koreanValue: 'ì‹¤ë¡  ê³„í”¼' }
    ];

    const expertCafes = ['ë§ì›ë™í‹°ì•„ì´í”¼', 'ì¹´í˜ì˜¨ì¦ˆ', 'ë¸Œë¼ìš´í•¸ì¦ˆ', 'ë””ì €íŠ¸39'];
    const expertRoasteries = ['ê°ê°ì»¤í”¼', 'ë¹ˆìŠ¤ë¹ˆìŠ¤', 'ì¹´í˜ë“œë¡­', 'ë§ˆë©”ìŠ¤'];
    const expertCoffees = ['íŒŒë‚˜ë§ˆ ê²Œì´ìƒ¤', 'ìë©”ì´ì¹´ ë¸”ë£¨ë§ˆìš´í‹´', 'í•˜ì™€ì´ ì½”ë‚˜', 'ì˜ˆë©˜ ëª¨ì¹´'];

    for (let i = 0; i < count; i++) {
      const isHomeCafe = includeHomeCafe && Math.random() > 0.3;
      
      data.push({
        coffeeInfo: {
          cafeName: isHomeCafe ? undefined : expertCafes[i % expertCafes.length],
          roastery: expertRoasteries[i % expertRoasteries.length],
          coffeeName: expertCoffees[i % expertCoffees.length],
          origin: ['Panama', 'Jamaica', 'Hawaii', 'Yemen'][i % 4],
          variety: ['Geisha', 'Typica', 'Bourbon', 'Mocha'][i % 4],
          altitude: ['1800m', '2000m', '2200m', '2400m'][i % 4],
          process: ['Washed', 'Natural', 'Honey', 'Carbonic Maceration'][i % 4],
          temperature: 'hot' as const
      },
        roasterNotes: `í”„ë¦¬ë¯¸ì—„ ìŠ¤í˜ì…œí‹° ì»¤í”¼ #${i + 1}. í…Œë£¨ì•„ì˜ íŠ¹ì„±ê³¼ ê°€ê³µë²•ì˜ ì¡°í™”ê°€ ë§Œë“¤ì–´ë‚¸ ë³µí•©ì  í–¥ë¯¸`,
        selectedFlavors: expertFlavors.slice(0, Math.floor(Math.random() * 8) + 4),
        selectedSensoryExpressions: this.generateExpertSensoryData(),
        sensoryAttributes: {
          body: Math.floor(Math.random() * 5) + 1,
          acidity: Math.floor(Math.random() * 5) + 1,
          sweetness: Math.floor(Math.random() * 5) + 1,
          finish: Math.floor(Math.random() * 5) + 1,
          mouthfeel: ['Clean', 'Creamy', 'Juicy', 'Silky'][Math.floor(Math.random() * 4)] as MouthfeelType,
          bitterness: Math.floor(Math.random() * 5) + 1,
          balance: Math.floor(Math.random() * 5) + 1
      },
        matchScore: {
          total: Math.floor(Math.random() * 30) + 80, // 80-100 range
          flavorScore: Math.floor(Math.random() * 15) + 40,
          sensoryScore: Math.floor(Math.random() * 15) + 40
      },
        personalComment: `ì „ë¬¸ê°€ íí•‘ ë…¸íŠ¸ #${i + 1}: í…Œë£¨ì•„ì˜ ë…ì°½ì„±ê³¼ ê°€ê³µë²•ì˜ ì •êµí•¨ì´ ì¡°í™”ë¡­ê²Œ í‘œí˜„ëœ exceptional coffee`,
        mode: isHomeCafe ? 'home_cafe' : 'cafe',
        homeCafeData: isHomeCafe ? this.generateExpertHomeCafeData() : undefined
    });
  }

    return data;
}

  /**
   * HomeCafe focused data
   */
  private static generateHomeCafeData(count: number): TastingData[] {
    const data: TastingData[] = [];
    const drippers = ['V60', 'KalitaWave', 'Origami', 'Chemex', 'FellowStagg'] as const;
    const filters = ['bleached', 'natural', 'wave', 'chemex'] as const;
    const pourTechniques = ['center', 'spiral', 'pulse', 'continuous'] as const;
    const grinders = [
      { brand: 'ì»¤ë§¨ë‹¨í…Œ', model: 'C40' },
      { brand: 'í•˜ë¦¬ì˜¤', model: 'Mini Mill Slim' },
      { brand: 'ë°”ë¼ì§œ', model: 'Encore' },
      { brand: 'í ë¡œìš°', model: 'Ode' }
    ];

    for (let i = 0; i < count; i++) {
      const grinder = grinders[i % grinders.length];
      const dripper = drippers[i % drippers.length];
      
      data.push({
        coffeeInfo: {
          roastery: `í™ˆì¹´í˜ ë¡œìŠ¤í„°ë¦¬ ${i + 1}`,
          coffeeName: `í™ˆì¹´í˜ ì›ë‘ ${i + 1}`,
          origin: ['Ethiopia', 'Colombia', 'Kenya', 'Guatemala'][i % 4],
          variety: ['Heirloom', 'Caturra', 'SL28', 'Bourbon'][i % 4],
          altitude: ['1600m', '1800m', '2000m'][i % 3],
          process: ['Washed', 'Natural', 'Honey'][i % 3],
          temperature: 'hot' as const
      },
        roasterNotes: `í™ˆì¹´í˜ ì‹¤í—˜ #${i + 1} - ${dripper} ì¶”ì¶œë²• í…ŒìŠ¤íŠ¸`,
        selectedFlavors: [
          { level: 1, value: 'Fruity', koreanValue: 'ê³¼ì¼í–¥' },
          { level: 2, value: 'Berry', koreanValue: 'ë² ë¦¬ë¥˜' }
        ],
        selectedSensoryExpressions: this.generateHomeCafeSensoryData(),
        sensoryAttributes: {
          body: Math.floor(Math.random() * 5) + 1,
          acidity: Math.floor(Math.random() * 5) + 1,
          sweetness: Math.floor(Math.random() * 5) + 1,
          finish: Math.floor(Math.random() * 5) + 1,
          mouthfeel: 'Clean' as const,
          bitterness: Math.floor(Math.random() * 5) + 1,
          balance: Math.floor(Math.random() * 5) + 1
      },
        matchScore: {
          total: Math.floor(Math.random() * 50) + 50,
          flavorScore: Math.floor(Math.random() * 25) + 25,
          sensoryScore: Math.floor(Math.random() * 25) + 25
      },
        personalComment: `í™ˆì¹´í˜ ì‹¤í—˜ ê¸°ë¡ #${i + 1}`,
        mode: 'home_cafe',
        homeCafeData: {
          equipment: {
            dripper: dripper,
            dripperSize: dripper === 'V60' ? '02' : dripper === 'KalitaWave' ? '185' : undefined,
            filter: filters[i % filters.length],
            grinder: {
              brand: grinder.brand,
              model: grinder.model,
              setting: `${Math.floor(Math.random() * 20) + 10}í´ë¦­`
          },
            server: 'í•˜ë¦¬ì˜¤ ì„œë²„ 600ml',
            scale: 'Acaia Pearl',
            kettle: 'í ë¡œìš° ìŠ¤íƒœê·¸ EKG'
        },
          recipe: {
            doseIn: Math.floor(Math.random() * 5) + 15, // 15-20g
            waterAmount: Math.floor(Math.random() * 50) + 240, // 240-290ml
            ratio: `1:${Math.floor(Math.random() * 3) + 15}`, // 1:15 to 1:17
            waterTemp: Math.floor(Math.random() * 5) + 91, // 91-95Â°C
            bloomWater: 30 + Math.floor(Math.random() * 10), // 30-40g
            bloomTime: 30 + Math.floor(Math.random() * 15), // 30-45s
            bloomAgitation: Math.random() > 0.5,
            pourTechnique: pourTechniques[i % pourTechniques.length],
            numberOfPours: Math.floor(Math.random() * 3) + 2, // 2-4 pours
            totalBrewTime: Math.floor(Math.random() * 60) + 150, // 2.5-3.5 minutes
            drawdownTime: Math.floor(Math.random() * 30) + 20, // 20-50s
            agitation: ['none', 'swirl', 'stir'][i % 3] as AgitationType,
            agitationTiming: 'ë§ˆì§€ë§‰ ë¶“ê¸° í›„'
        },
          notes: {
            grindAdjustment: `${Math.floor(Math.random() * 3) + 1}í´ë¦­ ë” êµµê²Œ`,
            channeling: Math.random() > 0.8,
            mudBed: Math.random() > 0.9,
            tasteResult: 'ì‚°ë¯¸ê°€ ë°ì•„ì§€ê³  ë‹¨ë§›ì´ ë” ì„ ëª…í•´ì§',
            nextExperiment: 'ë¬¼ì˜¨ë„ë¥¼ 2ë„ ë‚®ì¶°ì„œ ì‹œë„í•´ë³´ê¸°'
        }
      }
    });
  }

    return data;
}

  /**
   * Large dataset for statistics testing
   */
  private static generateStatisticsTestData(count: number, includeHomeCafe: boolean): TastingData[] {
    const data: TastingData[] = [];
    
    // Generate diverse data for statistical analysis
    for (let i = 0; i < count; i++) {
      const scenario = Math.floor(Math.random() * 3);
      
      if (scenario === 0) {
        data.push(...this.generateBeginnerData(1, includeHomeCafe));
    } else if (scenario === 1) {
        data.push(...this.generateIntermediateData(1, includeHomeCafe));
    } else {
        data.push(...this.generateExpertData(1, includeHomeCafe));
    }
  }

    return data;
}

  /**
   * Generate beginner-level sensory expressions
   */
  private static generateBeginnerSensoryData(): SelectedSensoryExpression[] {
    const beginnerExpressions = [
      { category: 'ì‚°ë¯¸', expression: 'ì‹±ê·¸ëŸ¬ìš´', isSelected: true },
      { category: 'ë‹¨ë§›', expression: 'ë‹¬ì½¤í•œ', isSelected: true },
      { category: 'ë°”ë””', expression: 'ë¶€ë“œëŸ¬ìš´', isSelected: true }
    ];
    
    return beginnerExpressions.slice(0, Math.floor(Math.random() * 2) + 1);
}

  /**
   * Generate intermediate-level sensory expressions
   */
  private static generateIntermediateSensoryData(): SelectedSensoryExpression[] {
    const intermediateExpressions = [
      { category: 'ì‚°ë¯¸', expression: 'ë°œë„í•œ', isSelected: true },
      { category: 'ë‹¨ë§›', expression: 'ë†ë°€í•œ', isSelected: true },
      { category: 'ì“´ë§›', expression: 'ì¹´ì¹´ì˜¤ ê°™ì€', isSelected: true },
      { category: 'ë°”ë””', expression: 'í¬ë¦¬ë¯¸í•œ', isSelected: true },
      { category: 'ì• í”„í„°', expression: 'ê¸¸ê²Œ ë‚¨ëŠ”', isSelected: true }
    ];
    
    return intermediateExpressions.slice(0, Math.floor(Math.random() * 3) + 2);
}

  /**
   * Generate expert-level sensory expressions
   */
  private static generateExpertSensoryData(): SelectedSensoryExpression[] {
    const expertExpressions = [
      { category: 'ì‚°ë¯¸', expression: 'ì™€ì¸ ê°™ì€', isSelected: true },
      { category: 'ë‹¨ë§›', expression: 'ê¿€ ê°™ì€', isSelected: true },
      { category: 'ì“´ë§›', expression: 'ë‹¤í¬ ì´ˆì½œë¦¿ ê°™ì€', isSelected: true },
      { category: 'ë°”ë””', expression: 'ë²¨ë²³ ê°™ì€', isSelected: true },
      { category: 'ì• í”„í„°', expression: 'ë³µí•©ì ì¸', isSelected: true },
      { category: 'ë°¸ëŸ°ìŠ¤', expression: 'ì¡°í™”ë¡œìš´', isSelected: true }
    ];
    
    return expertExpressions.slice(0, Math.floor(Math.random() * 4) + 3);
}

  /**
   * Generate HomeCafe-specific sensory expressions
   */
  private static generateHomeCafeSensoryData(): SelectedSensoryExpression[] {
    const homeCafeExpressions = [
      { category: 'ì‚°ë¯¸', expression: 'ë°ì€', isSelected: true },
      { category: 'ë‹¨ë§›', expression: 'ì€ì€í•œ', isSelected: true },
      { category: 'ë°”ë””', expression: 'ê¹”ë”í•œ', isSelected: true }
    ];
    
    return homeCafeExpressions;
}

  /**
   * Generate simple HomeCafe data for beginners
   */
  private static generateSimpleHomeCafeData(): HomeCafeData {
    return {
      equipment: {
        dripper: 'V60' as PouroverDripper,
        filter: 'bleached' as FilterType,
        grinder: {
          brand: 'í•˜ë¦¬ì˜¤',
          model: 'Mini Mill',
          setting: 'ì¤‘ê°„'
      }
    },
      recipe: {
        doseIn: 20,
        waterAmount: 300,
        ratio: '1:15',
        waterTemp: 95,
        bloomWater: 40,
        bloomTime: 30,
        totalBrewTime: 240,
        pourTechnique: 'center' as PourTechnique,
        numberOfPours: 3
    },
      notes: {
        tasteResult: 'ì²˜ìŒ ì‹œë„í•´ë³¸ í™ˆë¸Œë£¨ì‰, ìƒê°ë³´ë‹¤ ê´œì°®ì•˜ìŒ'
    }
  };
}

  /**
   * Generate detailed HomeCafe data for intermediate users
   */
  private static generateDetailedHomeCafeData(): HomeCafeData {
    return {
      equipment: {
        dripper: 'V60' as PouroverDripper,
        grinder: {
          brand: 'ì»¤ë§¨ë‹¨í…Œ',
          model: 'C40',
          setting: '18í´ë¦­'
      },
        filter: 'bleached' as FilterType,
        kettle: 'êµ¬ìŠ¤ë„¥ ì£¼ì „ì',
        scale: 'ë””ì§€í„¸ ì €ìš¸'
    },
      recipe: {
        doseIn: 22,
        waterAmount: 350,
        ratio: '1:16',
        waterTemp: 93,
        bloomWater: 44,
        bloomTime: 45,
        totalBrewTime: 180,
        pourTechnique: 'pulse' as PourTechnique,
        numberOfPours: 3
    },
      notes: {
        grindAdjustment: 'ê·¸ë¼ì¸ë”©ì„ 1í´ë¦­ ë” êµµê²Œ ì¡°ì •',
        tasteResult: 'ì‚°ë¯¸ê°€ ë” ë°ì•„ì§€ê³  ê· í˜•ê°ì´ ì¢‹ì•„ì§',
        nextExperiment: 'ë¸”ë£¸ ì‹œê°„ì„ 15ì´ˆ ë” ëŠ˜ë ¤ë³´ê¸°'
    }
  };
}

  /**
   * Generate expert-level HomeCafe data
   */
  private static generateExpertHomeCafeData(): HomeCafeData {
    const expertDrippers = ['V60', 'Origami', 'April', 'Orea'] as const;
    const expertTechniques = ['spiral', 'pulse', 'multiStage'] as const;
    
    return {
      equipment: {
        dripper: expertDrippers[Math.floor(Math.random() * expertDrippers.length)],
        dripperSize: '02',
        filter: 'bleached',
        grinder: {
          brand: 'EK43',
          model: 'Mahlkonig',
          setting: '8.5'
      },
        server: 'Hario V60 Range Server',
        scale: 'Acaia Lunar',
        kettle: 'Fellow Stagg EKG Pro'
    },
      recipe: {
        doseIn: 20,
        waterAmount: 320,
        ratio: '1:16',
        waterTemp: 93,
        bloomWater: 40,
        bloomTime: 45,
        bloomAgitation: true,
        pourTechnique: expertTechniques[Math.floor(Math.random() * expertTechniques.length)],
        numberOfPours: 5,
        pourIntervals: [45, 30, 30, 30, 30],
        totalBrewTime: 210,
        drawdownTime: 25,
        agitation: 'swirl',
        agitationTiming: 'ë¸”ë£¸ í›„, ë§ˆì§€ë§‰ ë¶“ê¸° í›„'
    },
      notes: {
        grindAdjustment: 'TDS 1.35 ëª©í‘œ, 0.2 ë¯¸ì„¸ ì¡°ì •',
        channeling: false,
        mudBed: false,
        tasteResult: 'í–¥ë¯¸ì˜ ë³µí•©ì„±ì´ ê·¹ëŒ€í™”ë˜ë©´ì„œë„ í´ë¦°í•œ í”¼ë‹ˆì‹œ ë‹¬ì„±',
        nextExperiment: 'ë¬¼ì˜ ë¯¸ë„¤ë„ í•¨ëŸ‰ ì¡°ì •ì„ í†µí•œ ì‚°ë¯¸ ë°¸ëŸ°ìŠ¤ ìµœì í™”'
    }
  };
}

  /**
   * Create mock data in the database
   */
  static async createMockData(options: MockDataOptions): Promise<number> {
    try {
      Logger.info('ğŸ¯ Starting mock data creation', 'service', { data: { options } });
      
      // Step 1: Generate mock records
      Logger.debug('ğŸ“ Step 1: Generating mock records...', 'service');
      const mockRecords = this.generateTastingRecords(options);
      Logger.info(`ğŸ“ Generated ${mockRecords.length} mock records`, 'service', { data: { count: mockRecords.length } });
      
      // Step 2: Get realm service
      Logger.debug('ğŸ”§ Step 2: Getting RealmService instance...', 'service');
      const realmService = RealmService.getInstance();
      Logger.debug('âœ… RealmService instance obtained', 'service');
      
      // Step 3: Initialize if needed
      if (!realmService.isInitialized) {
        Logger.info('ğŸ”§ Step 3: Initializing RealmService...', 'service');
        await realmService.initialize();
        Logger.info('âœ… RealmService initialized', 'service');
      } else {
        Logger.debug('âœ… RealmService already initialized', 'service');
      }

      let successCount = 0;
      
      // Step 4: Save records one by one
      Logger.debug(`ğŸ’¾ Step 4: Saving ${mockRecords.length} records...`, 'service');
      
      for (let i = 0; i < mockRecords.length; i++) {
        const record = mockRecords[i];
        try {
          Logger.debug(`ğŸ’¾ Saving record ${i + 1}/${mockRecords.length}`, 'service', { 
            data: { 
              recordIndex: i, 
              coffeeName: record.coffeeInfo?.coffeeName,
              roastery: record.coffeeInfo?.roastery,
              mode: record.mode,
              hasMatchScore: !!record.matchScore,
              hasSensoryAttributes: !!record.sensoryAttributes
            } 
          });
          
          // Validate record before saving
          const isValid = this.validateTastingData(record);
          if (!isValid) {
            Logger.error(`âŒ Record ${i + 1} validation failed`, 'service', { data: { record } });
            continue;
          }
          
          const saved = await realmService.saveTasting(record);
          successCount++;
          
          Logger.debug(`âœ… Successfully saved record ${i + 1}`, 'service', { 
            data: { 
              recordId: saved.id,
              coffeeName: saved.coffeeName,
              roastery: saved.roastery
            } 
          });
      } catch (error) {
          Logger.error(`âŒ Failed to save mock record ${i + 1}`, 'service', { 
            error: error instanceof Error ? error : new Error(String(error)),
            errorMessage: error instanceof Error ? error.message : String(error),
            errorStack: error instanceof Error ? error.stack : undefined,
            data: { 
              recordIndex: i, 
              recordSummary: {
                coffeeName: record.coffeeInfo?.coffeeName,
                roastery: record.coffeeInfo?.roastery,
                mode: record.mode
              }
            }
          });
      }
    }

      Logger.info(`ğŸ‰ Mock data creation completed: ${successCount}/${mockRecords.length} records saved`, 'service', { data: { successCount, total: mockRecords.length } });

      return successCount;
  } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      const errorStack = error instanceof Error ? error.stack : undefined;
      
      Logger.error('ğŸ’¥ Failed to create mock data', 'service', { 
        error: error instanceof Error ? error : new Error(String(error)),
        errorMessage,
        errorStack,
        data: { options }
      });
      
      // Don't re-throw, return 0 to indicate failure
      return 0;
  }
}

  /**
   * Clear all mock data from database
   */
  static async clearMockData(): Promise<void> {
    try {
      const realmService = RealmService.getInstance();
      
      if (!realmService.isInitialized) {
        await realmService.initialize();
    }

      await realmService.clearAllTastings();
      
      Logger.info('Cleared all mock data successfully', 'service', { action: 'clearMockData' });
  } catch (error) {
      Logger.error('Failed to clear mock data', 'service', { error: error instanceof Error ? error : new Error(String(error)) });
      throw error;
  }
}

  /**
   * Validate mock data structure
   */
  static validateTastingData(data: TastingData): boolean {
    try {
      // Check required fields
      if (!data.coffeeInfo?.roastery || !data.coffeeInfo?.coffeeName) {
        Logger.warn('Invalid coffee info', 'service', { data: { roastery: data.coffeeInfo?.roastery, coffeeName: data.coffeeInfo?.coffeeName } });
        return false;
    }

      // Check sensory attributes
      if (!data.sensoryAttributes?.body || !data.sensoryAttributes?.acidity) {
        Logger.error('Invalid sensory attributes', 'service', { error: new Error('Invalid sensory attributes') });
        return false;
    }

      // Check match score
      if (!data.matchScore?.total || data.matchScore.total < 0 || data.matchScore.total > 100) {
        Logger.error('Invalid match score', 'service', { error: new Error('Invalid match score') });
        return false;
    }

      // Check HomeCafe data if present
      if (data.mode === 'home_cafe' && data.homeCafeData) {
        if (!data.homeCafeData.equipment?.dripper || !data.homeCafeData.recipe?.doseIn) {
          Logger.error('Invalid HomeCafe data', 'service', { error: new Error('Invalid HomeCafe data') });
          return false;
      }
    }

      return true;
  } catch (error) {
      Logger.error('Error validating mock data', 'service', { error: error instanceof Error ? error : new Error(String(error)) });
      return false;
  }
}

  /**
   * Get current mock data count
   */
  static async getMockDataCount(): Promise<number> {
    try {
      const realmService = RealmService.getInstance();
      
      if (!realmService.isInitialized) {
        await realmService.initialize();
    }

      const tastings = await realmService.getTastingRecords({ isDeleted: false });
      return Array.from(tastings).length;
  } catch (error) {
      Logger.error('Failed to get mock data count', 'service', { error: error instanceof Error ? error : new Error(String(error)) });
      return 0;
  }
}
}